# Lesson 5: More advanced topics
<!-- 
2.5.Modules and packages. 
2.5.1. Documentation. 
2.5.2. Comments.
2.5.3. Creating and using modules. 
2.5.4. Namespaces. 
2.5.5. Creating packages.

2.6.Exception handling 
2.6.1. Catching exceptions. 
2.6.2. Raising exceptions.

3.4.Documentation 
3.4.1. Using a documentation generator (such as pyDoc or Javadoc) to create technical documentation for easier maintenance.

3.5.Exception handling 
3.5.1. Raising exceptions. 
3.5.2. Raising exceptions and showing friendly error messages to the user.
-->

## Dcoumenting your script
Some say that good code is self-explanatory, there is no need for extra information. Although we should do our best to write clean and clear code, it can only show how it does something, not why! 

### Comments 
Comments are needed to add that extra information which will help someone reading the code later to understand the whole picture.
~~~
valid = False
# Loop until the user enters a valid number
while not valid:
    num = int(input('Enter a number between 1 and 10: '))
    if num >= 1 and num <= 10:
        valid = True
    else:
        print('invalid, try again')
~~~

### Docstrings
Python documentation strings (or docstrings) are a way of documenting Python functions (and modules). A docsting is defined as a string on the first statement in the function code should describe what the function does, not how. It is good practice to use docstrings with all your functions. Docstrings can be accessed at runtime by using the `__doc__` attribute.

The doc string line should begin with a capital letter and end with a period. 
~~~
def dcoumentedFunction():
    ''' The first line should be a short description.

    More details can be added after skipping a line.
    '''
    five = 4 + 1
  
print(dcoumentedFunction.__doc__)
~~~

## Exceptions
Sometimes a script can cause errors (e.g. FileNotFound, InvalidInput, etc) while running some risky operations. Python will raise an exception is such cases, allowing the developer to handle these errors and avoid the script from crashing.

### Handling exceptions
To be able to handle these exceptions you need to set up a harness. The **risky** code is placed within a try clause and be tried (executed) statement by statement. If an exception is raised, the rest of the try block will be skipped and the except clause will be executed.
~~~
try:
    answer = 15/0
except:
    print("Something went wrong")
~~~
The above sample will catch any exception. If you know what specific exception you are expecting, you can specify it as below
~~~
try:
    answer = 15/0
except ZeroDivisionError:
    print("Invalid maths operation; Division by zero")
~~~
### Task
Write a function that asks the user to enter a number and returns it. Use a loop and exception handling to make sure that a number is actually entered. *Hint: ValueError is raised when casting a string to an int fails.*

### try ... except ... else 
The optional else clause at the end of a try-except harness holds code that must be executed if the try-clause does not raise an
exception.
~~~
try:
    something_risky()
except IOError:
    print("IOERROR !!!")
else:
    do_this_on_success()
~~~

### try ... except ... finally
The optional finally clause is always executed before leaving the try statement, whether an
exception has occurred or not (usually used for cleaning up).
~~~
try:
    something_risky()
except IOError:
    print("IOERROR !!!")
finally:
    close_the_door_behind_you()
~~~

### Raising exceptions
If one of your functions encounters a problem it cannot handle, it can also raise an exception as below:
~~~
raise ValueError('A very bad thing happened')
~~~

## Python odules
A module is a Python (.py) file containing a number of functions normally having a common functionality e.g. handling dates, generating random numbers, etc. The module name is the same as the file name e.g. datetime.py contains the datetime module. Normally there scrupts are not executed directly, but are imported other scripts.  

Have a look at [this sample](https://github.com/robert-abela/python/tree/master/src/lesson05/modules). The main script imports the magic module making it possible to use the functions in it. The main function uses the local function do_some_magic() which calls the two functions in the magic module to perform the tricks. 

You can import all the functions in a module or one particular function. You can even rename a module when importing it.
~~~
from module import *
from module import func1, func2
import module as mx
~~~

## References
* https://www.pythonforbeginners.com/basics/python-docstrings
* https://www.pythonforbeginners.com/error-handling/exception-handling-in-python
* https://www.learnpython.org/en/Modules_and_Packages
